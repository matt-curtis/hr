<!DOCTYPE html>
<html lang="en">
	
	<head>
		<meta charset="utf-8" />
		
		<title>HyphenLink Client</title>
		
		<link rel="stylesheet" href="../css/all.min.css" />
		<link rel="stylesheet" href="../css/hyphenlink-client.min.css" />

		<script src="../js/HyphenLink.js"></script>
	
		<!-- RIOT TAGS -->

		<script type="riot/tag">
			<connect-landing-page class={ connecting: connecting }>
				<div id="connect-landing-centered">
					<a href="#" class="hyphenlink-logo no-style-link"></a>
			
					<p id="connect-landing-prompt-text">
						{ status.message ? status.message : "To get started, enter the IP displayed in Hyphen." }
					</p>
					
					<div id="ip-input-wrapper">
						<input id="ip-input" type="text" placeholder="Enter IP" onkeyup={ this.ipKeyUp }
							 class={ center: 1, invalid: invalidInput } />
					</div>
			
					<a id="connect-button" onclick={ connect }
						class={ button: true, 'disable-interaction': connecting, disabled: !ipFieldHasValue() }>
						{ connecting ? "Connecting..." : "Connect" }
					</a>
			
					<p id="need-help-text"><a href="#">Need Help<span id="need-help-question-mark">?</span></a></p>
				</div>
			
				var self = this, root = this.root;
				var field;
			
				self.status = {};
			
				this.ipFieldHasValue = function(){
					return this["ip-input"].value.trim() != "";
				};
			
				this.ipKeyUp = function(e){
					var valid = self.ipFieldHasValue();
			
					self.invalidInput = !valid;
			
					if(e.keyCode == 13 && valid){
						field.blur(); self.connect();
					}
				};
			
				this.connect = function(e){
					self.connecting = true;
			
					self.status.message = "Talking to Hyphen...";
			
					HyphenLink.connect(field.value, "HyphenLink Client", function(success){
						if(!success){
							self.connecting = false;
			
							self.status.message = "Failed to connect. Make sure the IP is correct, and that you're on the same network as your iPhone.";
			
							self.update();
			
							field.focus();
						} else {
							localStorage["ip"] = field.value;
			
							self.unmount(true); riot.mount("app-page"); 
						}
					});
				};
			
				this.on("mount", function(){
					root.setAttribute("mounted", "");
			
					field = document.getElementById("ip-input");
			
					var lastIP = localStorage["ip"];
			
					if(lastIP){
						field.value = lastIP;
						self.invalidInput = false;
			
						self.update();
					}
				});
			
				this.on("unmount", function(){
					root.removeAttribute("mounted");
				});
				
			</connect-landing-page>
		</script>

		<script type="riot/tag">
			<app-page>
				<header class="pseudo-clear-both">
					<span id="alpha-logo" class="hyphenlink-alpha-logo"></span>
			
					<input type="file" id="file-input" multiple="" class="display-none" onchange={ importFileInputChanged } accept="application/epub+zip" />
					<label for="file-input" class="float-right">
						<a class="button small float-right">Import ePubs</a>
					</label>
				</header>
			
				<div id="tab-bar">
					<span data-for-tab="library" class="tab-item selected" onclick={ tabClicked }>Library</span>
					<span data-for-tab="imports" class="tab-item" onclick={ tabClicked }
						data-superscript-text={ getFormattedPendingImportTasksCount() }>Imports</span>
				</div>
			
				<div id="tab-container">
			
					<div class="tab-view visible" id="library-tab-view" data-tab-id="library">
						<div id="library-sidebar" class={ disabled: isEditing }>
							<input id="search-field" type="text" placeholder="Search" oninput={ searchQueryChanged } />
			
							<div id="book-list">
								<div each={ book, i in books } if={ bookMatchesSearch(book) }
									class={ 'book-list-item': 1, selected: isCurrentBook(book) } onclick={ bookListItemClicked }>
									
									<span class="book-list-item-thumb no-thumb" style="background-image: url({ getThumbURLForBook(book) })"></span>
									<span class="book-list-item-details">
										<div class="book-list-item-title">{ book.title }</div>
										<div class="book-list-item-series" if={ book.series }>{ formattedSeries(book) }</div>
										<div class="book-list-item-author">{ book.author }</div>
									</span>
								</div>
							</div>
			
							<div id="book-count">{ books.length } books in library</div>
						</div>
						
						<div id="library-book-info" class={ 'display-none': !selectedBook }>
							<div class="library-book-info-thumb no-thumb" style="background-image: url({ getThumbURLForBook(selectedBook) })"></div>
							
							<div class="library-book-info-text" if={ !isEditing }>
								<div class="library-book-info-title">{ selectedBook.title }</div>
								<div class="library-book-info-series" if={ selectedBook.series }>{ formattedSeries(selectedBook) }</div>
								<div class="library-book-info-author">{ selectedBook.author }</div>
								
								<a class="button small" href={ getDownloadURLForBook(selectedBook) }>Download ePub</a>
								<a class="button small" onclick={ enterEditMode }>Edit</a>
								<a class="button small destructive" onclick={ deleteSelectedBook }>Delete</a>
							</div>
			
							<div class="library-book-info-text" if={ isEditing }>
								<input type="text" class="library-book-info-title medium" value={ selectedBook.title } placeholder="Title" />
								<input type="text" class="library-book-info-author medium" value={ selectedBook.author } placeholder="Author" />
								
								<div if={ isEditing }>
									<a class="button small" onclick={ saveEdits }>Save</a>
									<a class="button small destructive" onclick={ cancelEdits }>Cancel</a>
								</div>
							</div>
			
							<div class="clear-left"></div>
			
							<div class="library-book-info-description">
								<raw data-html={ selectedBook.desc.length > 0 ? selectedBook.desc : 'No description.' } />
							</div>
						</div>
			
					</div>
			
					<div class="tab-view" id="imports-tab-view" data-tab-id="imports">
						
						<div class="import-list-item" data-status={ importItem.status } each={ importItem, i in imports }>
							<div class="import-list-item-file-name">{ importItem.fileName }</div>
							<div class="import-list-item-status">{ importItem.statusMessage }</div>
						</div>
			
					</div>
			
				</div>
			
				var self = this, root = this.root;
			
				//	Elements
			
				var libraryBookInfoEl;
			
				//	Tabs
			
				var currentTab = "library";
			
				this.tabClicked = function(e){
					var tabItem = e.target;
			
					//	Visual Indicator
			
					root.querySelector(".tab-item.selected").classList.remove("selected");
			
					tabItem.classList.add("selected");
			
					//	Hide former tab
			
					root.querySelector(".tab-view.visible").classList.remove("visible");
			
					//	Update
			
					libraryBookInfoEl.scrollTop = 0;
			
					currentTab = tabItem.dataset.forTab;
			
					//	Show new tab
			
					root.querySelector("[data-tab-id='" + currentTab + "']").classList.add("visible");
				};
			
				//	Book
			
				this.formattedSeries = function(book){
					if(!book.series) return;
			
					return book.series + ", #" + (book.seriesIndex+1);
				};
			
				//	Book List
			
				this.selectedBook;
				this.books = [];
			
				this.isCurrentBook = function(book){
					return (book.id == this.selectedBook.id);
				};
			
				this.bookListItemClicked = function(e){
					var book = e.item.book;
			
					self.selectedBook = book;
			
					libraryBookInfoEl.scrollTop = 0;
				};
			
				this.getThumbURLForBook = function(book){
					return HyphenLink.Books.getURLForBookThumb(book.id);
				};
			
				this.getDownloadURLForBook = function(book){
					return HyphenLink.Books.getURLForBookEpub(book.id);
				};
			
				this.deleteBook = function(book){
					var proceed = confirm("Are you sure you want to delete this book?");
			
					if(!proceed) return;
			
					this.books.splice(this.books.indexOf(book), 1);
			
					if(book == self.selectedBook) self.selectedBook = null;
			
					HyphenLink.Books.deleteBooks([ book.id ]);
				};
			
				this.deleteSelectedBook = function(){
					self.deleteBook(self.selectedBook);
				};
			
				this.updateBookList = function(){
					HyphenLink.Books.getBooks(function(json){
						var books = json.books;
			
						books.sort(function(a, b){
							return new Date(b.dateAdded) - new Date(a.dateAdded);
						});
			
						self.books = books;
			
						console.log(self.books);
			
						self.update();
					});
				};
			
				this.updateBookWithTitleAndAuthor = function(book, title, author){
					book.title = title;
					book.author = author;
			
					HyphenLink.Books.updateBooks([ book.id ], { title: title, author: author });
				};
			
				//	Editing
			
				this.isEditing = false;
			
				this.enterEditMode = function(){
					self.isEditing = true;
				};
			
				this.saveEdits = function(){
					var titleInput = root.getElementsByClassName("library-book-info-title")[0], title = titleInput.value;
					var authorInput = root.getElementsByClassName("library-book-info-author")[0], author = authorInput.value;
			
					self.updateBookWithTitleAndAuthor(self.selectedBook, title, author);
			
					self.isEditing = false;
			
					self.update();
				};
			
				this.cancelEdits = function(){
					self.isEditing = false;
				};
			
				//	Book Upload
			
				var imports = [];
				var importNotificationListener =
					HyphenLink.Socket.addNotificationListener(HyphenLink.NOTIFICATION_IMPORT_STATUS_UPDATE, function(notification){
						var importItem = getImportItemWithId(notification.identifier);
			
						console.log("import notification for id: "+notification.identifier);
			
						if(notification.error){
							importItem.status = "failed";
							importItem.statusMessage = notification.error;
						} else {
							importItem.status = "success";
							importItem.statusMessage = "Imported successfully.";
						}
			
						self.update();
					});
			
				this.imports = imports;
			
				this.getPendingImportTasksCount = function(){
					var count = 0;
			
					for(var i = 0, len = imports.length; i<len; i++){
						if(imports[i].status == "pending") count++;
					}
			
					return count;
				};
			
				this.getFormattedPendingImportTasksCount = function(){
					var count = self.getPendingImportTasksCount();
					
					return (count == 0 ? null : count);
				};
			
				var generateUUID = function(){
					var uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c){
						var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
						
						return v.toString(16);
					});
			
					return uuid.toUpperCase();
				};
			
				var getImportItemWithId = function(identifier){
					for(var i = 0; i<imports.length; i++){
						if(imports[i].identifier == identifier) return imports[i];
					}
				};
			
				this.importFileInputChanged = function(e){
					var fileInput = e.target;
					var files = fileInput.files;
			
					//	Update imports array
			
					[].forEach.call(files, function(file, i){
						var temporaryId = generateUUID();
			
						imports.unshift({
							fileName: file.name, identifier: temporaryId,
							 statusMessage: "Uploading...", status: "pending"
						});
			
						HyphenLink.Books.importEpubs([ file ], function(json){
							var jsonImports = json.imports;
							var jsonImportItem;
			
							for(var identifier in jsonImports) jsonImportItem = jsonImports[identifier];
			
							console.log(json);
			
							var importItem = getImportItemWithId(temporaryId);
			
							if(jsonImportItem.error){
								importItem.status = "failed";
								importItem.statusMessage = jsonImportItem.error;
							} else {
								importItem.statusMessage = "Importing...";
							}
							
							importItem.identifier = identifier;
			
							self.update();
						});
					});
			
					//	Reset element
			
					fileInput.value = "";
				};
			
				//	Searching
			
				var getSearchString = function(){
					var value = self["search-field"].value;
			
					return value ? value.trim() : "";
				};
			
				this.searchQueryChanged = function(e){
					self.update();
				};
			
				this.bookMatchesSearch = function(book){
					var query = getSearchString().toLowerCase();
			
					if(query == "") return true;
			
					var title = book.title.toLowerCase();
					var author = book.author.toLowerCase();
			
					return (title.indexOf(query) != -1 || author.indexOf(query) != -1);
				};
			
				//	Events
			
				var notificationListener;
			
				this.on("mount", function(){
					root.setAttribute("mounted", "");
			
					libraryBookInfoEl = document.getElementById("library-book-info");
			
					notificationListener =
						HyphenLink.Socket.addNotificationListener(HyphenLink.NOTIFICATION_BOOKS_DID_UPDATE, function(notification){
							self.updateBookList();
						});
			
					HyphenLink.Socket.onClose = function(){
						self.unmount(true);
			
						riot.mount("connect-landing-page");
					};
			
					self.updateBookList();
				});
			
				this.on("unmount", function(){
					root.removeAttribute("mounted");
			
					HyphenLink.Socket.onClose = null;
			
					notificationListener.remove();
					notificationListener = null;
			
					importNotificationListener.remove();
					importNotificationListener = null;
				});
			
			</app-page>
		</script>

		<script type="riot/tag">
			<raw>
				var self = this;
			
				var updateHTML = function(){
					self.root.innerHTML = opts["data-html"] || "";
				};
			
				updateHTML();
			
				this.on("updated", updateHTML);
			</raw>
		</script>
	</head>

	<body>
		<!-- LANDING PAGE -->

		<div id="connect-landing-page" riot-tag="connect-landing-page"></div>

		<!-- APP PAGE -->

		<div id="app-page" riot-tag="app-page"></div>

		<!-- APP INITIALIZATION -->

		<script src="../js/riot+compiler.min.js"></script>
		<script>riot.mount("raw, connect-landing-page"); </script>
	</body>

</html>